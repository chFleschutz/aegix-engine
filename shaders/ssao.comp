#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0, r8) uniform image2D ssaoMap;
layout(set = 0, binding = 1) uniform sampler2D positionMap;
layout(set = 0, binding = 2) uniform sampler2D normalMap;
layout(set = 0, binding = 3) uniform sampler2D noiseMap;

layout(set = 0, binding = 4) uniform SSAO
{
	vec4 samples[64];
} ssao;

layout(push_constant, std140) uniform Push
{
	mat4 view;
	mat4 projection;
} push;

const int sampleCount = 64;
const vec2 noiseScale = vec2(4.0);
const float radius = 0.5;
const float bias = 0.025;

void main()
{
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = vec2(pixelCoords) / imageSize(ssaoMap);

	vec3 worldPosition = texture(positionMap, uv).rgb;
	vec3 viewPosition = (push.view * vec4(worldPosition, 1.0)).xyz;

	vec3 worldNormal = texture(normalMap, uv).rgb;
	vec3 viewNormal = mat3(push.view) * worldNormal;

	vec3 noise = vec3(texture(noiseMap, uv * noiseScale).xy, 0.0);

	vec3 tangent = normalize(noise - viewNormal * dot(noise, viewNormal));
	vec3 bitangent = cross(viewNormal, tangent);
	mat3 TBN = mat3(tangent, bitangent, viewNormal);

	float occlusion = 0.0;
	for (int i = 0; i < sampleCount; i++)
	{
		vec3 samplePos = TBN * ssao.samples[i].xyz;
		samplePos = viewPosition + samplePos * radius;

		vec4 offset = push.projection * vec4(samplePos, 1.0);
		offset.xyz /= offset.w;					// Perspective division
		offset.xyz = offset.xyz * 0.5 + 0.5;	// Transform to range [0, 1] 

		float sampleDepth = (push.view * texture(positionMap, offset.xy)).z;

		float rangeCheck = smoothstep(0.0, 1.0, radius / abs(viewPosition.z - sampleDepth));
		occlusion += (sampleDepth >= samplePos.z + bias ? 1.0 : 0.0) * rangeCheck;  
	}

	occlusion = 1.0 - (occlusion / float(sampleCount));
	imageStore(ssaoMap, pixelCoords, vec4(occlusion, 0.0, 0.0, 1.0));
}